//
//  TestLocationViewController.swift
//  Radius
//
//  Created by Kassandra Capretta on 1/25/20.
//  Copyright Â© 2020 Kassandra Capretta. All rights reserved.
//

import UIKit
import CoreLocation
import MapKit

class TestLocationViewController: UIViewController, CLLocationManagerDelegate, MKMapViewDelegate {

    @IBOutlet weak var mapView: MKMapView!
    
    let coordinate = CLLocationCoordinate2DMake(33.97823607957177, -118.43823725357653)
    
    var locationManager : CLLocationManager = CLLocationManager()
    
    // Authorize use of location
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
      mapView.showsUserLocation = (status == .authorizedAlways)
    }
    
    // Entering region
    func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {
             showAlert(withTitle: "You've entered \(region.identifier)", message: "Happy hopping!")
    }
    
    // Exiting region
    func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {
           showAlert(withTitle: "You've exited \(region.identifier)", message: "")
    }
    
    // Creating region and notifying when exit / enter
    func region(with geotification: Geotification) -> CLCircularRegion {
      let region = CLCircularRegion(center: geotification.coordinate,
        radius: geotification.radius,
        identifier: geotification.identifier)
      region.notifyOnEntry = (geotification.eventType == .onEntry)
      region.notifyOnExit = !region.notifyOnEntry
      return region
    }

    // Monitoring region, if not "error"
    func startMonitoring(geotification: Geotification) {
      if !CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) {
        showAlert(withTitle:"Error", message: "Geofencing is not supported on this device!")
        return
      }
      
        // Might not be needed
      if CLLocationManager.authorizationStatus() != .authorizedAlways {
        let message = """
          Your geotification is saved but will only be activated once you grant
          Geotify permission to access the device location.
          """
        showAlert(withTitle:"Warning", message: message)
      }
      
      let fenceRegion = region(with: geotification)
      
      locationManager.startMonitoring(for: fenceRegion)
    }
    
    // Might not be needed
    func stopMonitoring(geotification: Geotification) {
      for region in locationManager.monitoredRegions {
        guard let circularRegion = region as? CLCircularRegion,
          circularRegion.identifier == geotification.identifier else { continue }
        locationManager.stopMonitoring(for: circularRegion)
      }
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        //setupData()
        mapView.userTrackingMode = .follow
        mapView.delegate = self
        mapView.showsUserLocation = true
        
        // Region of coordinate
        mapView.region = MKCoordinateRegion(center: coordinate, latitudinalMeters: 1000, longitudinalMeters: 1000)
        
        let title = "Marina Bar Hop"
        let restaurantAnnotation = MKPointAnnotation()
        restaurantAnnotation.coordinate = coordinate
        restaurantAnnotation.title = title
        mapView.addAnnotation(restaurantAnnotation)

        let regionRadius = 300.0
        let circle = MKCircle(center: coordinate, radius: regionRadius)
        mapView.addOverlay(circle)
        
        self.locationManager.requestAlwaysAuthorization()
        self.locationManager.delegate = self as CLLocationManagerDelegate
        
        //Zoom to user location
        if let userLocation = locationManager.location?.coordinate {
            let viewRegion = MKCoordinateRegion(center: userLocation, latitudinalMeters: 200, longitudinalMeters: 200)
            mapView.setRegion(viewRegion, animated: false)
        }
        
        // mapView Function
        func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {
            let circleRenderer = MKCircleRenderer(overlay: overlay)
            circleRenderer.strokeColor = UIColor.red
            circleRenderer.lineWidth = 1.0
            return circleRenderer
        }
          
    }
    
}
